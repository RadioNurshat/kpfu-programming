## 50 Способов решить матрицу


 **Перед началом:**
 *Как ввести динамическую матрицу?*
 Она же по сути массив массивов, поэтому:
 

    int ** matrix = new int*[n];
    for(int i = 0; i < n; i++){
	    matrix[i] = new int[m];
	    for (int j = 0; j<m; j++){
		    matrix[i][j] = //Нужное значение при инициализации, хоть рандом, хоть ввод с потока
		}
    }
    
*Как вывести динамическую матрицу?*

    for(int i = 0; i < n; i++){
	    for (int j = 0; j<m; j++){
		    std::cout << matrix[i][j] << " ";
		}
    }
**Под matrix в коде дальше будет подразумеваться именно такой ввод матрицы, где n - количество строк, m - количество столбцов**

## Вот они сверху вниз: задачи по матрице
### Задача 1
Идем по строкам и ставим 0 в случайное место

    for (int i = 0; i < x; i++) {
        int position = rand() % y;
        matrix[i][position] = 1;
    }
   
### Задача 2
Тут даже код не требуется, задать `rand() % 10 ` при инициализации и все
### Задача 25
Рядом с инициализацией элемента матрицы:

    if (matrix[i][j] < min[i]) {
                min[i] = matrix[i][j];
            }
min - Массив минимальных элементов матрицы, инициализируется через:

    int* min = new int[n];
    for (int i = 0; i < n; i++) min[i] = 10000;
### Задача 26
ШОК! Тахир поменял местами первую и последнюю строки матрицы! Узнайте как, нужно всего лишь один раз в коде:

    swap(matrix[0], matrix[n - 1]);
### Задача 30
При инициализации/Вводе матрицы считаем минимум:

    min = ((matrix[i][j]<min)?matrix[i][j]:min);
И меняем каждый элемент по условию:

    if(matrix[i][j] % 2 == 0){
	    matrix[i][j] = min;
	}
### Задача 31
Вывод транспонированной матрицы:

    for (int i = 0; i < x; i++) {
        for (int j = 0; j < y; j++) {
            transposed[j][i] = matrix[i][j];
            cout << transposed[i][j] << " ";
        }
        cout << endl;
    }
   ### Задача 47
   Создадим небольшой вспомогательный массив, чтобы определять, поставили ли мы уже 0 в этом столбце.
   

    bool* library = new bool[m];
    for (int i = 0; i < m; i++) {
        library[i] = false;
    }
И соответственно случайно расставляем 0 в матрице:

    int l = 0;
    for (int i = 0; i < n; i++) {
        while (true) {
            int zero = rand() % m;
            if (!library[zero]) {
                library[zero] = true;
                matrix[i][zero] = 0;
                break;
            }
        }
    }

 И создаем новую матрицу, в которой строки соответственно переставлены.
 

    int** replaced = new int* [n];
    for (int i = 0; i < n; i++) {
        int place = 0;
        for (int j = 0; j < m; j++) {
            if (matrix[i][j] == 0) place = j;
        }
        replaced[place] = matrix[i];
    }
